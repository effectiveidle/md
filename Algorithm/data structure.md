# 第一章 绪论

## （a）计算机与算法

- 计算是利用计算机这种工具可以重复地机械地完成的过程
- 研究计算的规律和技巧来实现高效、低耗的计算，Computing science

- 算法：即特定计算模型下，解决特定问题的指令序列
- 输入输出、确定性、可行性、正确性、有穷性；（鲁棒性、重用性）

Hailstone sequence未必是一个算法，程序 ≠ 算法

- 好算法：正确、健壮、可读、效率

## （b）计算模型和复杂度分析

- 理想模型

同一问题的多种算法为评判其优劣，抽象出一个理想的模型来准确地测量算法，不再依赖于种种具体的因素

- Turing Machine：Tape，Head，State

- Random Access Machine

与TM模型一样，都是对一般计算工具的简化与抽象，使我们能够独立于具体的平台，对算法的效率做出可信的比较与评判，在这些模型中，将算法的运行时间转化为算法需要执行的**基本操作次数**

- 成本：运行时间+所需存储空间，问题的规模往往是决定计算成本的主要因素

- T(n)，在规模为n的所有实例中，只关注最坏情况(成本最高)


## （c）大O记号

- 渐进分析

只看计算成本随着问题规模增大后主要的、长远的变化趋势

- 大O记号

T(n)=O(f(n))：当n足够大后，有T(n) ≤ c*f(n)

- 高效解

O(1)：常数复杂度，不含转向(循环、调用、递归等)，必顺序执行

O(logn)：对数复杂度，低于任何多项式复杂度，常底数无所谓，因为logan = logab * logbn

- 有效解

O(n^c)：统称多项式复杂度，抹掉低次项、常数项和系数

- 难解

O(2 ^n)：指数复杂度

- 增长速度

2^n > n^2 > nlogn > n > sqrt(n) > logn

## （d）算法分析

- 两个主要任务：正确性和复杂度


- 级数

1. 算数级数：与末项平方同阶
2. 幂方级数：比幂次高出一阶
3. 几何级数：与末项同阶
4. 调和级数
5. 对数级数

- 循环

![image-20210202101339349](../img/image-20210202101339349.png)

- 封底估算

抓住问题的主要方面

## （e）递归与迭代

- 从递归(recursion)的程序转向更加高效的迭代(iteration)


- Decrease and conquer

将大规模问题划分为一个规模缩减的问题和一个平凡的问题，分别求解子问题，由子问题的解得到原问题的解

- 递归跟踪

直观形象，仅适用于简明的递归模式

- 递推方程

间接抽象，更适用于复杂的递归模式

- Divide and conquer

将大规模问题划分为若干子问题，分别求解子问题，由子问题的解得到原问题的解

### 7-二分递归：数组求和

### 8-二分递归：Max2

### 9-Max2：二分递归

## （xc）动态规划

### 1-动态规划

### 2-Fib()：递推方程

### 3-Fib()：封底估算

### 4-Fib()：递归跟踪

### 5-Fib()：迭代

### 6-最长公共子序列

### 7-LCS：递归

### 8-LCS：理解

### 9-LCS：复杂度

### A-LCS：动态规划

# 第二章 向量(上)

## （a）接口与实现

### 1-接口与实现

![image-20210204095044614](../img/image-20210204095044614.png)

### 2-向量ADT

### 3-接口操作实例

### 4-构造与析构

![image-20210204101940259](../img/image-20210204101940259.png)

### 5-复制

![image-20210204102432200](../img/image-20210204102432200.png)

## （b）可扩充向量

### 1 可扩充向量

### 2 动态空间管理

### 3 递增式扩容

### 4 加倍式扩容

<img src="../img/image-20210204110719861.png" alt="image-20210204110719861" style="zoom: 80%;" />

### 5 分摊复杂度

## （c）无序向量

### 1 概述

### 2: 循秩访问

重载下标操作符"[ ]"

### 3 插入

先判断是否需要expand()扩容

### 4 区间删除

删除后若有必要则shrink()缩容

### 5 单元素删除

### 6 查找

input-sensitive

### 7 唯一化

去重操作

### 8 遍历

利用函数指针统一对各元素分别实施操作

## （d1）有序向量：唯一化

### 1 有序性

有序向量任意一对相邻元素顺序，**相邻逆序对**数目可以用来度量向量的逆序程度

### 1-2 唯一化（低效版）

### 1-3 复杂度（低效版）

### 1-4 唯一化（高效版）

将不相等的元素右移

### 1-5 实例与分析（高效版）

## （d2）有序向量：二分查找

### 1 概述

### 2 接口

### 3 语义

确定≤e的最后一个元素

### 4 原理

### 5 实现

### 6 实例

### 7 查找长度

分别针对查找成功与失败，从最好、最坏、平均等角度评估，均为O(1.5*logn)

# 第二章 向量(下)

## （d3）有序向量：Fibonacci查找

### 1 构思

转向左右分支前的比较次数不等，而递归深度却相同

### 2 实现

### 3 实例

### 4 最优性

## （d4）有序向量：二分查找（改进）

### 1 构思

2个分支

## 2 版本B

### 3 语义

### 4 版本C

--lo

### 5 正确性

## （d5）有序向量：插值查找

### 1 原理

有序向量中各元素为均匀且独立的随机分布，interpolation search

### 2 实例

### 3 性能分析

每经过一次比较n缩至√n

### 4 字宽折半

### 5 综合对比

<img src="../img/image-20210208090643209.png" alt="image-20210208090643209" style="zoom:67%;" />

## （e）起泡排序

### 1 构思

### 2 改进

### 3 反例

### 4 再改进

返回本次冒泡最右侧逆序对的位置，表示该位置后面无需再比较

### 5 综合评价

stability

## （f）归并排序

### 1 归并排序：构思

### 2 归并排序：主算法

### 3 二路归并：实例

### 4 二路归并：实现

只有前一段数组需要开辟空间存储

### 5 二路归并：正确性

### 6 归并排序：性能分析

# 第三章 列表

# 第四章 栈与队列

# 第五章 二叉树

# 第六章 图

