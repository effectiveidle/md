- # 基础核心内容

- 1.进程的虚拟地址空间内存划分和布局

- 2.函数的调用堆栈详细过程

- 3.程序编译链接原理

- \---------------------------------------------------------------------------------------------------------------------------------- 

- #  对象的优化：

- ## 1.对象使用过程中对四个基本函数的调用：

- 利用临时对象构造或赋值：用临时对象拷贝构造一个新对象的时候，临时对象不产生，直接构造新对象(编译器优化)；但是用临时对象给其他对象赋值的时候会创建临时对象，赋值后再析构临时对象，临时对象的生命周期是所在的语句 ；不能用指针指向临时对象，因为此时临时对象出语句就会析构，指针为变成野指针；但是可以引用(必须用常引用)，因为引用为临时对象取了一个别名

- 临时对象的生成的两种方式：显式和隐式

- 各类对象的构造和析构过程：首先初始化全局变量，静态局部变量初始化是在第一次运行到它的时候，new的对象建在堆上需要自己释放，静态局部变量析构在局部变量之后全局变量之前

- ## 2.函数调用过程中对象背后对四个基本函数的调用

- 传参：函数调用时实参传递给形参，是一个初始化过程会调用拷贝构造函数，函数执行结束时，会析构形参

- 函数返回局部对象：会拷贝构造一个临时对象，然后将局部对象析构

- ## 3.三条对象优化的原则

- ①函数参数传递过程中，对象优先按引用传递，不要按值传递（能优化掉按值传递时形参的拷贝构造和析构）

- ②函数返回对象的时候，应该优先返回一个临时对象，而不要返回一个函数内定义的局部对象（能优化掉局部对象的拷贝构造和析构）

- ③接收返回值是对象的函数调用的时候，优先按初始化的方式接收，不要按赋值的方式接收

- ## 4.CMyString的代码问题

-  

- \----------------------------------------------------------------------------------------------------------------------------------

-  

- \----------------------------------------------------------------------------------------------------------------------------------

-  

- \----------------------------------------------------------------------------------------------------------------------------------

-  

- \----------------------------------------------------------------------------------------------------------------------------------

-  

- \----------------------------------------------------------------------------------------------------------------------------------

-  

- \----------------------------------------------------------------------------------------------------------------------------------

- # 智能指针

-  原理：利用栈上的对象出作用域自动析构的特征，来做到资源的自动释放

-  解决浅拷贝问题：

- 1.不带引用计数的智能指针(同一个资源只允许一个智能指针管理)

- auto_ptr：始终让最后一个智能指针管理资源，将前面的指针置空

- scoped_ptr：私有化拷贝构造函数和赋值运算符函数

- unique_ptr：删除了普通的拷贝构造函数和赋值运算符函数，提供了带右值引用参数的拷贝构造函数和赋值运算符函数

- 2.带引用计数的智能指针(多个智能指针可以管理同一个资源)

- 两者都使用了原子类型来保证线程安全

- shared_ptr：强智能指针，可以改变资源的引用计数，构造一个辅助类作为计数器使用，并声明智能指针为其友元类

- weak_ptr：不会改变资源的引用计数，要访问所引用的对象时必须先转换为shared_ptr，可以用来避免强智能指针循环引用的问题(定义对象时使用强智能指针，引用对象时使用弱智能指针)

-  解决循环引用(交叉引用)问题，造成资源泄露问题， 对象new的资源无法释放

-  定义对象的时候使用强智能指针，引用对象的时候使用弱智能指针

- 多线程访问共享对象的线程安全问题

-  使用强弱智能指针

- 删除器：默认释放资源的方式是delete，其他资源可能需要重定义释放资源的方式

- 自定义删除器：使用lambda表达式；智能指针有两个模板类型参数，一个是管理的资源类型，第二个是删除器类型；智能指针的析构函数里是对一个函数对象的调用

- \----------------------------------------------------------------------------------------------------------------------------------

- # lambda表达式

- 定义：表示一个可调用的函数对象

- 原理：编译器会生成一个匿名类的匿名对象，并在类中重载函数调用运算符

- 完整格式：：[capture list] (parameter list) mutable exception ->return type {function body};

- 其他格式：

- ![计算机生成了可选文字: 2 3 [capture1](params飚1）一冫returntype{functiond君 [capture1](params飚1）{function0y} [capture1]{function0y} 悭1声明了con引类型的表达种类型的表达不能改扌甫获列表中的值． 悭2省踽了返回值类型但懌器可以根奄以下规则准断土Lama表达蕊的返回类型（1） function0y中存在urn语旬则该Lambda表达蕊的返回类型苎return旬的返回类型谁走． *function0y中：殳有urn语旬则返回值为v00类型。 悭3省踽了参数列表，类似昔匾丞数的无参丞数： 〔2）．如](../img/clip_image004-1612422845842.png)

- [ ]：表示不捕获任何外部变量

- [ = ]：以传值的方式捕获外部的所有变量

- [ & ]：以传引用的方式捕获外部的所有变量

- [ =，&a ]：以传引用方式捕获a变量，其他变量以传值方式捕获

- [ a，b ]：以传值的方式捕获变量a和变量b

- [a，&b]：以传值的方式捕获变量a，以传引用的方式捕获变量b

- [ this ]：捕获外部的this指针

- lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量

- 捕获外部变量就是函数对象的构造函数的形参列表 

- 形参列表、返回值和操作代码就是函数对象的小括号重载函数的形参列表、返回值和操作代码

- 应用：作为可调用的函数对象传递给泛型算法函数；如 sort()函数