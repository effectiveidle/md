- - **Week1**

- 1.Linux基本命令，使用VMware安装Ubuntu，使用xshell连接ubuntu，使用vim编辑代码使用g++编译

- Day1：20191229

- linux的架构

- <img src="file:///C:/Users/99139/AppData/Local/Temp/msohtmlclip1/01/clip_image001.jpg" alt="img" style="zoom: 67%;" />

- xshell ssh协议（ Secure Shell）

- linux常用命令

- vim使用

- Day2：20191230

- gcc，g++编译器

- 2.编译和链接的过程，静态链接和动态链接的区别

- 源码->预处理  .i ->编译 .s ->汇编->链接

- 静态链接和动态链接， 动态链接出现的原因就是为了解决静态链接中提到的两个问题，一方面是空间浪费，另外一方面是更新困难。 动态链接因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，性能会有一定损失。

- 静态库和动态库

- windows: 

-   静态库  **.lib

-   动态库  **.dll

- 3.C++和C区别：命名空间

- Day3：20200101

- 命名空间

- 三种使用方式：

- 作用域限定符

- using编译指令

- using声明机制

- 命名空间可以嵌套使用

- 命名空间还可以不定义名字，不定义名字的命名空间称为匿名命名空间

- 匿名命名空间只能在本文件的作用域内有效

- C标准库中的函数定义在匿名命名空间中

- 4.C++和C区别：const关键字

- const

- 修饰变量，必须初始化，默认状态下仅在文件内有效

- 修饰引用，reference to const

- 修饰指针，pointer to canst，canst pointer

- 修饰成员函数

- 修饰对象

- 5.C++和C区别：new/delete表达式

- new/delete 是C++的运算符或表达式

- 开辟/回收一个元素的空间：

- int * p = new int(1);

- cout << *p << endl;

- delete p;

- 开辟/回收一个数组的空间：

- int * p = new int[10]( );//开辟数组时，要记得采用[ ]

- for(int idx = 0; idx != 10; ++idx)

- {

-    p[idx] = idx;

- } 

- delete  [ ]p; //回收时，也要采用[ ]

- 6.C++和C区别：引用

- 类型 & 引用名 = 目标变量名

- 引用作为函数参数（引用传递）：在没有引用之前，如果我们想通过形参改变实参的值，只有使用指针才能到达目的， 当用引用作为函数的参数时，其效果和用指针作为函数参数的效果相当。当调用函数时，函数中的形参就会被当成实参变量或对象的一个别名来使用，也就是说此时函数中对形参的各种操作实际上是对实参本身进行操作，而非简单的将实参变量或对象的值拷贝给形参。

- ？引用作为函数的返回值

- 返回的变量其生命周期一定要大于函数

- 不能返回局部变量的引用

- 不要轻易返回一个堆空间变量的引用，除非有了内存回收的策略

- 引用总结：

- \1. 在引用的使用中，单纯给某个变量取个别名是毫无意义的，引用的目的主要用于在函数参数传递中，解决大块数据或对象的传递效率和空间不如意的问题。

- \2. 用引用传递函数的参数，能保证参数传递中不产生副本，提高传递的效率，且通过const的使用，保证了引用传递的安全性。

- \3. 引用与指针的区别是，指针通过某个指针变量指向一个变量后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。

- 7.C++和C区别：函数重载

- 函数重载

- 8.C++和C区别：C++强制转换

- Day4：20200102

- C++强制转换：Static_cast， const_cast

- 9.C++和C区别：默认参数

- 默认参数

- C++可以给参数定义默认值， 这样调用时，若不给参数传递实参，函数会按指定的默认值进行工作。

- 一般默认参数在函数声明中提供, 若给某一参数设置了默认值，那么在参数表中其后所有的参数都必须也设置默认值.

- 10.C++和C区别：inline函数

- inline函数

- 关键字 inline 必须与函数定义体放在一起才能使函数成为内联

- inline一般都是直接放在头文件中实现

- 为一个小操作（如int max（））定义一个函数有许多好处，但是调用函数比求解等价表达式要慢得多。在大多数的机器上，调用函数都要做很多工作：调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新位置执行。即对于这种简短的语句使用函数开销太大。

- 在C语言中，我们使用带参数的宏定义这种借助编译器的优化技术来减少程序的执行时间，而在C++中使用内联(inline)函数。

- 内联函数作为编译器优化手段的一种技术，用来降低程序运行时间， 当内联函数收到编译器的指示时，即可发生内联：编译器将使用函数的定义体来替代函数调用语句，这种替代行为发生在编译阶段而非程序运行阶段。

- 11.C++和C区别：异常处理

- 异常处理：throw，try-catch、

- 12.string

- C和C++风格字符串比较

- string

- 字符串字面值与string是不同的类型

- 字符字面值/字符串字面值和string对象相加的时候，必须确保+两侧的运算对象至少有一个是string

- s1.find（）

- s1.substr（）

- 13.程序内存布局

- 内存布局

-  

- ![img](file:///C:/Users/99139/AppData/Local/Temp/msohtmlclip1/01/clip_image003.jpg)

- 栈区：由操作系统维护，存放函数的参数值、局部变量等，函数结束后在栈上的空间由操作系统回收，内存分配是连续的

- 堆区：由用户申请和释放

- 14.类和对象

- 面向对象的思维方式

- 类(数据成员和成员函数）

- 关键字：实现封装和继承

- class 和 struct：默认访问权限不同 private/public

- Day5：20200103

- 构造函数（Constructor）：函数的名字与类名相同，没有返回值，没有返回类型，可以被重载

- ​          初始化列表(初始化表达式）

- ​          默认构造函数，有参构造函数

- ​           特殊数据成员的初始化：const数据成员，引用数据成员，类对象成员必须在初始化列表中初始化

- ​                                静态数据成员在类的外部定义和初始化

- 拷贝构造函数（复制构造函数）：类名（const 类名 &rhs）

- ​     //固定写法

- ​    //1. 引用符号不能去掉，如果去掉，根据拷贝构造函数的

- ​    //调用时机来看，会导致无穷递归，直到栈溢出，程序崩溃

- ​    //2. const关键字不能去掉，如果去掉，当传递过来的是

- ​    //右值时，就无法正确调用拷贝构造函数

- const左值引用能够绑定到右值

- 非const左值引用无法绑定到右值

- 缺省（默认）的拷贝构造函数：浅拷贝（拷贝指针地址）

- 显示定义：深拷贝（拷贝指针所指空间内容)

- 析构函数（Destructor）：~

- 析构函数在哪些时候会被调用呢？

- \1. 对于全局定义的对象，每当程序开始运行，在主函数 main 接受程序控制权之

- 前，就调用构造函数创建全局对象，整个程序结束时，自动调用全局对象的析

- 构函数。

- \2. 对于局部定义的对象，每当程序流程到达该对象的定义处就调用构造函数，在

- 程序离开局部对象的作用域时调用对象的析构函数。

- \3. 对于关键字 static 定义的静态局部变量，当程序流程第一次到达该对象定义处

- 调用构造函数，在整个程序结束时调用析构函数。

- \4. 对于用 new 运算符创建的对象（堆对象），每当创建该对象时调用构造函数，当用 delete

- 删除该对象时，调用析构函数。

- ​      //由于数据成员_brand指向了堆空间的区域，

- ​    //所以必须要显式提供一个析构函数进行回收

- ​    //析构函数要清理的是对象的数据成员申请的资源

- ​    //而对象本身所占据的空间，不是由析构函数来回收的

- ​    //只要对象被销毁，就会自动调用析构函数

- 赋值运算符函数：类名 & operator（const 类名 &rhs）

- &rhs是对传入的参数取其地址，this代表当前对象的地址

- 只有当&rhs!=this时才进行后面的操作，也就意味着当rhs和this是同一个对象的时候(地址相同)直接返回

- 这么做是为了防止对象给自己赋值

- this指针： 在类中定义的非静态成员函数中都有一个隐含的this指针，它代表的就是当前对象本身，它作为成员函数的第一个参数，由编译器自动补全。

- Day6：20200104

- 特殊的成员函数：

- static成员函数: 静态成员函数可以直接通过类名进行调用 静态成员函数的参数列表中不含有隐含的 this 指针

- const成员函数： 只能读取类数据成员，而不能修改之

- 对象的组织：

- const对象

- 指向对象的指针

- 对象数组

- 堆对象

- 15.单例模式之懒汉式

- 单例模式： 

- 这个设计模式主要目的是想在整个系统中只能出现类的一个实例，即一个类只有一个对象，并为系统提供一个全局访问点

- 属于创建型模式，它提供了一种创建对象的方式，确保只有单个对象被创建。

- 单例的实现主要是通过以下两个步骤：

- 1.将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；

- 2.在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。

- - **Week2**

- 1.new/delete表达式在类中的具体应用

- Day7：20200106

- new/delete表达式在类中的使用

- 使用new表达式时的三个步骤

- 使用delete表达式时的两个步骤

-  new/delete在类中的的应用：要求一个类只能创建栈对象

- ​                          要求一个类只能创建堆对象

- 2.输入输出流                 

- 输入输出流:iostream, fstream,sstream

- 流：字节序列

- 输入：设备流向内存

- 流的条件状态（iostate)：badbit，failbit，eofbit，goodbit

- 确定流状态的最简单方法就是将它当作一个条件来使用，但只能告诉我们流是否有效，而无法知道具体发生了什么

- 标准库提供了一组成员函数来查询和操作这些状态

- 流的通用操作

- 缓冲区

- 刷新输出缓冲区：flush,ends,endl

- ​                unibuf 

- 构造函数：explicit fstream(const char* filename, openmode mode = in|out);

- 文件模式：openmode

- ifstream：1.get( ) 2. ifs>>word 3.getline(ifs,line)

- ofstream:1.ofs<<line

- cout/cerr/clog: cout的输出可以重定向到一个文件中，而cerr必须输出在显示器上。

- cerr与clog的区别，两者都是标准错误流, 区别在于cerr不经过缓冲区,直接向显示器输出信息,而clog中的信息存放在缓冲区,缓冲区endl时才输出.

- 对输入流操作：seekg（）与tellg（）

- 对输出流操作：seekp（）与tellp（）

- seekg（）是对输入文件定位，它有两个参数：第一个参数是偏移量，第二个参数是基地址。

- tellg( )得到文件指针当前指向的文件位置。

- stringstream : 构造函数：explicit stringstream(const string& str, openmode mode =ios_base::in|ios_base::out);

- \> 将其他类型的数据转换成字符串 --> ostringstream

- \> 将字符串的数据转换成其他类型 --> istringstream

- 3.log4cpp

- Day8：20200107

- 日志系统

- 守护进程(daemon)是一类在后台运行

- 并且不受任何终端控制

- 的特殊进程，用于执行特定的系统任务。很多守护进程在系统引导的时候启动，并且一直运行直到系统关闭。另一些只在需要的时候才启动，完成任务后就自动结束。

- GitHub log库之log4cpp在linux下的使用

- 日志系统设计思路： 记录器、过滤器、格式化器、输出器

- Category(种类)、Appender(附加目的地)、Layout(布局)和Priority(优先级)

- Category负责向日志中写入信息，Appender负责指定日志的目的地，Layout负责设定日志的格式，Priority被用来指定Category的优先级和日志的优先级

- Log4cpp记录日志的原理如下：每个Category都有一个优先级，该优先级可以由setPriority方法设置，或者从其父Category中继承而来。每条日志也有一个优先级，当Category记录该条日志时，若日志优先级高于Category的优先级时，该日志被记录，否则被忽略。

- Category、Appender和Layout三者的关系如下：系统中可以有多个Category，它们都是继承自同一个根，每个Category负责记录自己的日志;每个Category可以添加多个Appender，每个Appender指定了一个日志的目的地，例如文件、字符流或者Windows日志，当Category记录一条日志时，该日志被写入所有附加到此Category的Appender;每个Append都包含一个Layout，该Layout定义了这个Appender上日志的格式。

- Layout： BasicLayout， PatternLayout

- Appender：OstreamAppender ，FileAppender

- Day9：20200108

- 解决3个难题：

- 1.[x]双向链表

- 2.[x]统计文件中出现的单词及频率

- 3.[x]封装log4cpp

- Day10：20200109

- 4.友元

- 友元函数：全局函数，成员函数

- 友元类

- 5.运算符重载

- 运算符重载： 对运算符进行重新定义，赋予其新的功能，以满足自定义类型进行类似的运算的需求

- 返回类型 operator 运算符(参数表)

- {

- //...

- }

- 规则

- \> 形式:

- ​      \> 普通函数(数据成员是public)

- ​        \+ - * / %

- ​        == != > < <= >=

- ​      \> 成员函数

- ​        =

- ​        ++  前置/后置 推荐使用前置形式

- ​        \--

- ​        +=  复合赋值运算符

- ​        ->  

- ​        *

- ​        ()  函数对象, 携带状态的

- ​        []

- ​        new

- ​        delete

- ​      \> 友元函数(数据成员是private)

- ​        \+ - * /

- ​        << 右操作数的形式是const引用（不能以成员函数形式重载）  cout << a;

- ​        \>> 右操作数的形式是非const引用

- ​        == != > < <= >=

- 所有的一元运算符，建议以成员函数重载

- 运算符 = () [] -> ->* ，必须以成员函数重载

- 运算符 += -= /= *= %= ^= &= != >>= <<= 建议以成员函数形式重载

- 其它二元运算符，建议以非成员函数重载

- 特殊运算符的重载：

- 自增自减运算符

- 赋值运算符

- 函数调用运算符

- 下标访问运算符

- 成员访问运算符

- 输入输出流运算符

- Day11：20200110

- 讲解作业： 1.[x]实现只能生成栈对象的代码

- ​           2.[x]实现只能生成堆对象的代码

- ​           3.[x]WordsCount

- ​          4.[x]Mylogger

- 6.类对象与其他类型的类型转换

- 1.将其他类型转换成自定义类型   //其他类型可以是内置类型，也可以是自定义类类型

- 由构造函数实现     //隐式转换

- \2. 由自定义类型向其他类型转换

- 由类型转换函数完成的，

- operator 目标类型（）

- {

-    ......

-    return ...;

- }

- 类型转换函数具有以下的特征:

- 必须是成员函数；

- 参数列表中没有参数；

- 没有返回值，但在函数体内必须以 return 语句返回一个目标类型的变量。

- 7.类作用域

- 就近原则

- 全局类

- 嵌套类（内部类）

- 局部类

- 8.设计模式之PIMPL

- 1.接口和实现分离

- 2.降低编译依赖，提高重编译速度

- 3.降低模块的耦合度

- 4.库升级后，源程序不需要重新编译

- 5.可以实现信息隐藏

- 9.单例模式的自动释放

- 1.饿汉式（嵌套类+静态对象）   //饿汉式会提前浪费内存空间和资源

- 2.饿汉式（atexit + destroy）  //int atexit(void (*func)(void))

- 3.饿汉式（pthread_once + atexit）

- 10.标准库中string的三种实现方式

- Day12：20200111

- 1.Eager Copy

- 2.COW //引用计数没有与数据成员放在一起，解决operator[ ]区分读操作与写操作的问题：用代理模式实现

- 3.SSO

- 4.fbstring

- - **Week3**

- 1.继承

- Day13：20200113

- C++ 中代码重用的方式之一就是采用继承。继承是面向对象程序设计中重要的特征

- 继承的定义：

- class 派生类

- : public/protected/private 基类

- { };

- 派生类的生成过程：

- 1.吸收基类的成员

- 2.改造基类的成员

- 3.添加自己的成员

- 继承的局限（不能从基类继承下来）：

- 1.构造函数

- 2.析构函数

- 3.赋值运算符函数

- 4.用户重载的operator new/delete运算符

- 5.友元关系

- 访问权限:

- ![img](file:///C:/Users/99139/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png)

-  

- ![img](file:///C:/Users/99139/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png)

- 派生类对象的构造和销毁

- 创建派生类对象时，系统首先通过派生类的构造函数来调用基类的构造函数，完成基类成员的初始化，而后对派生类中新增的成员进行初始化

- 当派生对象被销毁时，先调用派生类析构函数， 再调用派生类中成员对象的析构函数，之后再自动调用基类的析构函数。

- 多基继承（多基派生）

- 多基继承的派生类对象的构造和销毁

- 多基继承过程中会产生两种二义性：

- 1.成员名冲突二义性

- 2.菱形继承二义性

- 基类与派生类之间的相互转换：

- 派生类适应于基类

- base = derived;//ok

- Base & refBase = derived;//ok

- Base * pBase = &derived;//向上转型

- 派生类对象之间的复制控制：

- 在派生类的拷贝构造函数或赋值运算符函数中显示调用基类的~或~

- 2.容器

- vector，set，map

- Day14：20200114

- 3.多态

- 编译时多态（静态联编）：函数重载，运算符重载

- 运行时多态（动态联编）：虚函数

- C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。

- | **目的**：接口重用：封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都 | 是为了代码重用。而多态的目的则是为了接口重用。 |
  | ------------------------------------------------------------ | ---------------------------------------------- |
  |                                                              |                                                |

-  

- 虚函数的实现机制：

- 虚函数指针-->虚函数表

- 如果一个基类的成员函数定义为虚函数，那么它在所有派生类中也保持为虚函数

- 在使用**指向子类对象的基类指针，并调用子类中的覆盖函数**时，如果该函数不是虚函数，那么将调用基类中的该函数；如果该函数是虚函数，则会调用子类中的该函数。 覆盖指的是派生类的虚函数表中相应虚函数的入口地址被覆盖。虚函数表只读

- 虚函数的实际意义：

- 或许，很多小伙伴都会有这样一个疑问：如果想调用子类中的覆盖函数，直接通过子类对象，或者指向子类对象的子类指针来调用，不就没这个烦恼了吗？要虚函数还有什么用呢？

- 其实不然，虚函数的实际意义非常之大。比如在实际开发过程中，会用到别人封装好的框架和类库，我们可以通过继承其中的类，并覆盖基类中的函数，来实现自定义的功能。

- 但是，有些函数是需要框架来调用，并且API需要传入基类指针类型的参数。而使用虚函数就可以，将指向子类对象的基类指针来作为参数传入API，让API能够通过基类指针，来调用我们自定义的子类函数。这就是多态性的真正体现。

-  运行时多态被激活的条件:

- //1) 基类定义虚函数

- //2) 派生类覆盖虚函数

- //3) 创建派生类对象

- //4) 基类指针或者引用指向派生类对象

- //5) 基类指针或者引用调用虚函数

- 不能设置为虚函数的函数：

- 1.非成员函数

- 2.构造函数

- 3.静态成员函数

- 4.inline函数

- 5.友元函数

- 虚函数的访问方式:

- 动态联编：指针访问，引用访问，在成员函数中访问

- 静态联编：对象访问，构造函数和析构函数中访问

- 纯虚函数：提供接口

- 派生类必须实现所有的纯虚函数，才能够创建对象，否则它自己成为抽象类

- 一个抽象类只能作为基类来派生新类，不能创建抽象类的对象

- 抽象类：

- (1)类中含有纯虚函数： virtual 返回类型 函数名(参数包) = 0;

- (2)类中只定义了protected型的构造函数

- 重载vs覆盖vs隐藏：overload vs override vs oversee

- Day15：20200115

- 虚析构函数：如果类中定义了虚函数，析构函数也应该定义为虚析构函数，基类的析构函数设置为虚函数之后，派生类的析构函数会自动成为虚函数

- 带虚函数的多基派生：

- ![img](file:///C:/Users/99139/AppData/Local/Temp/msohtmlclip1/01/clip_image005.jpg)

-  

- ![img](file:///C:/Users/99139/AppData/Local/Temp/msohtmlclip1/01/clip_image005.jpg)

-  

- ![img](file:///C:/Users/99139/AppData/Local/Temp/msohtmlclip1/01/clip_image006.jpg)

-  

- ![img](file:///C:/Users/99139/AppData/Local/Temp/msohtmlclip1/01/clip_image006.jpg)

- Day16：20200116

- 虚拟继承

- virtual的特征：存在，间接，共享

- 测试虚函数表的存在:通过强制转换，得到了一个对象的二级指针

- ![img](file:///C:/Users/99139/AppData/Local/Temp/msohtmlclip1/01/clip_image007.png)

-  

- ![img](file:///C:/Users/99139/AppData/Local/Temp/msohtmlclip1/01/clip_image007.png)

- 虚拟继承：解决C++多重继承问题的一种手段，例如菱形继承中基类的成员变量在派生类中存了两份，第一会浪费存储空间，第二存在二义性问题

- ![img](file:///C:/Users/99139/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png)

-  

- ![img](file:///C:/Users/99139/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png)

- 虚基类并不是在声明基类时声明的，而是在声明派生类时，指定继承方式时声明的。因为一个基类可以在生成一个派生类时作为虚基类，而在生成另一个派生类时不作为虚基类。

- 虚基类表指针（virtual base table pointer）指向虚基类表（virtual table）

- //虚基指针所指向的虚基表的内容：

- //   1. 第一条内容表示的是该虚基指针距离所在的子对象的首地址的偏移

- //   2. 第二条内容表示的是该虚基指针距离虚基类子对象的首地址的偏移

- 单个虚继承与继承的区别：

- (1)多了一个虚基指针

- (2)虚基类位于派生类存储空间的末尾

- (3)’若派生类拥有自己的虚函数，会在派生类对象存储空间的开始位置产生自己的虚函数指针

- ![img](file:///C:/Users/99139/AppData/Local/Temp/msohtmlclip1/01/clip_image009.png)

-  

- ![img](file:///C:/Users/99139/AppData/Local/Temp/msohtmlclip1/01/clip_image009.png)

- **虚继承中派生类重写了基类的虚函数，并且在构造函数或者析构函数中使用指向基类的指针调用了该函数，编译器会为虚基类添加vtordisp域（4B）**

- 虚拟继承时派生类对象的构造和析构:

- 虚拟继承时，必须要在继承体系的每一层显示调用虚基类的构造函数来完成初始化。如果没有显示调用，就会调用虚基类的默认构造函数。

- 销毁顺序：

- 1.派生类的析构函数

- 2.派生类中成员对象的析构函数

- 3.普通基类的析构函数

- 4.虚基类的析构函数

- 效率分析

- 4.移动语义

- 左值vs右值： 左值是指表达式结束后依然存在的*持久化对象*，可以取地址；右值是指表达式结束时就不再存在的*临时对象*。

- const左值引用：作为函数参数时无法区分出左值和右值，缺点是只能读不能改

- 非const左值引用：不能绑定到（要求转换的表达式、字面常量和返回右值的表达式）

- 右值引用：&&，只能绑定到一个将要销毁的对象，不能将一个右值引用绑定到左值上，可以绑定到以上（类型），右值引用本身可能是左值也可能是右值

- 移动语义：解决临时对象带来的不必要的资源浪费，移动而非拷贝对象会提升性能

- 移动语义需要实现移动构造函数和移动赋值运算符函数

- 当同时定义了复制控制语义的函数和具有        语义的函数时，具有移动语义的函数会优先执行

- 编译器只对右值引用才能调用移动构造函数和移动赋值运算符函数

- 所以提供了：

- \#include <utility>   std::move：获得绑定到左值上的右值引用(显式的将左值引用转换成右值引用），从而让左值也能移动而不是拷贝

- 5.智能指针

- 资源管理：

- RAII技术：用对象的生命周期来管理资源，在构造函数中申请分配资源，在析构函数中释放资源，要保证资源申请与释放的顺序相反

- 对象语义（不允许复制或赋值）vs值语义

- 智能指针

- \#include <memory>

- Day17：20200117

- 动态内存管理经常会出现两种问题：一种是忘记释放内存，会造成内存泄漏；一种是尚有指针引用内存的情况下就释放了它，就会产生引用非法内存的指针。

- 1.std::unique_ptr ：

- (1)对它所指向的对象独享所有权

- (2)无法进行复制、赋值操作

- 当它被删除时会释放所指向的对象

- (3)具有移动语义，可作为容器元素

- 2.std::shared_ptr：强引用智能指针

- sp.use_count( );

- 引用计数采用的是原子操作，不会有线程安全的风险

- 3.std::weak_ptr：弱引用智能指针

- weak_ptr在执行赋值或者复制时，并不会导致引用计数+1

- 如果要访问资源，只能将weak_ptr提升成shared_ptr

- 2和3联合使用，可以解决shared_ptr循环引用导致的内存泄漏问题：（ 即A内部有指向B，B内部有指向A，这样对于A，B必定是在A析构后B才析构，对于B，A必定是在B析构后才析构A，这就是循环引用问题，违反常规，导致内存泄漏）

- 6.面向对象设计（OOP）

- UML：描述类之间的关系：

- 垂直方向：A is B：继承：空心的三角箭头

- 水平方向：A has B： 

- ​          关联：实线箭头

- ​          聚合：空心的菱形箭头

- ​          组合：实心的菱形箭头

- ​          A use B

- ​          依赖（耦合性最弱）：虚线箭头

- Day18：20200118

- TextQuery程序设计：接口层+实现层

- - **Week4**

- Day19：20200120

- 模板 ：泛型编程 

- 强类型程序设计：参与运算的所有对象的类型在编译时即确定下来，并且编译程序将进行严格的类型检查

- 解决强类型的严格性和灵活性的冲突引入了3种方式：

- 1.带参数的宏定义（原样替换）

- 2.重载函数

- 3.模板（类型参数化）

- 函数模板：

- template <模板参数表>

- 返回类型 函数名（参数列表）

- {

- ​     //......

- }

- 模板参数：                //可以设置默认值

- 1.class或typename修饰的类型参数

- 2.非类型参数，整型类型

- 模板参数实例化：

- 1.隐形实例化

- 2.显示实例化

- 重载的普通函数优先于函数模板调用，函数模板之间也可以重载

- 模板特化：

- template <>

- 返回类型 函数名<特化类型>（特化类型 参数1，特化类型 参数2，.......）

- 成员函数模板：在普通类中不用提供模板参数

- 可变模板参数：

- template <class...Args>

- void func(Args...args);

- Args为模板参数包：表示可以接受任意多个参数作为模板参数

- args为函数参数包，表示可以接受多个任意类型的参数

- 声明时...在右侧，使用时...在左侧(对参数包进行展开）

- 类模板：数据成员的类型或某个成员函数的参数或返回值的类型不确定

- 只有显示实例化，成员函数在类之外实现要加上模板形参列表

- STL：

- 1.container

- 序列式容器：

- （1）array（静态数组）

- （2）vector（动态数组）：_start , _finish ，_end_of_storage

- （3）deque（双端队列）：底层是n个片段组成，片段之间通过中控器联系起来，片段内部是连续的，片段之间不一定连续

- （4）list（双向链表）

- sort()，emerge()

- （5）forward_list（单链表）

- 2.iterator

- 3.adapter

- 4.algorithm

- 5.functor

- 6.allocator

- Day20：20200121

- 关联式容器：

- set，map

- #  

- # 积累：

- - **sizeof**

- 是一个运算符/操作符，并不是函数

- - **短路求值特性**

- &&  ， ||

- - **字符与字符串的存储**

- ![img](file:///C:/Users/99139/AppData/Local/Temp/msohtmlclip1/01/clip_image010.gif)

-  

- ![img](file:///C:/Users/99139/AppData/Local/Temp/msohtmlclip1/01/clip_image010.gif)

-  

- ![img](file:///C:/Users/99139/AppData/Local/Temp/msohtmlclip1/01/clip_image011.gif)

-  

- ![img](file:///C:/Users/99139/AppData/Local/Temp/msohtmlclip1/01/clip_image011.gif)

- - **全局区（static）**

- 全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。必须在类的外部定义和初始化静态数据成员，且不再包含 static 关键字

- static作用：

- static静态变量声明符。在声明它的程序块，子程序块或函数内部有效，值保持，在整个程序期间分配存储器空间，编译器默认值0。

- 是C++中很常用的修饰符，它被用来控制变量的存储方式和可见性。

- 为什么要引入static

- 函数内部定义的变量，在程序执行到它的定义处时，编译器为它在栈上分配空间，大家知道，函数在栈上分配的空间在此函数执行结束时会释放掉，这样就产生了一个问题： 如果想将函数中此变量的值保存至下一次调用时，如何实现？ 最容易想到的方法是定义一个全局的变量，但定义为一个全局变量有许多缺点，最明显的缺点是破坏了此变量的访问范围（使得在此函数中定义的变量，不仅仅受此函数控制）。

- 什么时候用static

- 需要一个数据对象为整个类而非某个对象服务，同时又力求不破坏类的封装性，即要求此成员隐藏在类的内部，对外不可见。

- 优势

- 可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。

- 静态数据成员

- C++ 允许使用 static （静态存储）修饰数据成员，这样的成员在编译时就被创建并初始化的（与之相比，对象是在运行时被创建的），且其实例只有一个，被所有该类的对象共享，静态数据成员和之前介绍的静态变量一样，当程序执行时，该成员已经存在，一直到程序结束，任何该类对象都可对其进行访问，静态数据成员存储在全局/静态区，并不占据对象的存储空间。

- 因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类对象时被定

- 义的。这意味着它们不是由类的的构造函数初始化的，一般来说，我们不能在类的

- 内部初始化静态数据成员，必须在类的外部定义和初始化静态数据成员，且不再包

- 含 static 关键字.

- 因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，在类外定义和初始化是保证static成员变量只被定义一次

- 静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这 有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，所以节省存储空间。第二，一旦利息需要改变时，只要改变一次， 则所有存款类对象的利息全改变过来了；

- 同全局变量相比，使用静态数据成员有两个优势：

- 静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性；

- 可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能；

-    //非静态成员函数可以访问静态数据成员

- 静态成员函数

- 与静态数据成员一样，我们也可以创建一个静态成员函数，它为类的全部服务而不是为某一个类的具体对象服务。静态成员函数与静态数据成员一样，都是类的内部实现，属于类定义的一部分。普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身。但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上讲，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数。

- 关于静态成员函数，可以总结为以下几点：

- 出现在类体外的函数定义不能指定关键字static；

- 静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数；

- 非静态成员函数可以任意地访问静态成员函数和静态数据成员；

- 静态成员函数不能访问非静态成员函数和非静态数据成员；

- 由于没有thi指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；

- - **->**

- 是C语言和C++语言的一个运算符，叫做指向结构体成员运算符，用处是使用一个指向结构体或对象的指针访问其内成员，通过结构体指针或对象指针即可访问该结构体或对象。

- - **expicit关键字:**

- 只对一个实参的构造函数有效，在C++中，我们有时可以将构造函数用作自动类型转换函数。但这种自动特性并非总是合乎要求的，有时会导致意外的类型转换，因此，C++新增了关键字explicit，用于关闭这种自动特性。即被explicit关键字修饰的类构造函数，不能进行自动地隐式类型转换，只能显式地进行类型转换。

- - **vector      : size()==capacity()时**

- 动态扩容

- - **Delegate      constructor**

- 委托构造函数

- - **左值和右值**

- P 121

- - **size_t**

- 类型定义在cstddef头文件中，该文件是C标准库的头文件stddef.h的C++版。它是一个与机器相关的unsigned类型，其大小足以保证存储内存中对象的大小。使用size_t可能会提高代码的可移植性、有效性或者可读性

- - **C++变量初始化**

- 在 C++ 程序中，变量在定义时可以初始化。如果不进行初始化，变量的初始值会是什么呢？

- 对全局变量和局部变量来说，这个答案是不一样的。

- 未初始化的全局变量全局变量在程序装入内存时就已经分配好了存储空间，程序运行期间其地址不变。对于程序员没有初始化的全局变量，程序启动时自动将其全部初始化为 0（即变量的每个比特都是 0）。

- 在大多数情况下，这是一种稳妥的做法。而且，将全局变量自动初始化为 0，是程序启动时的一次性工作，不会花费多少时间，所以大多数 C++ 编译器生成的程序，未初始化的全局变量的初始值都是全 0。

- 未初始化的局部变量对于局部变量，如果不进行初始化，那么它的初始值是随机的。局部变量定义在函数内部，其存储空间是动态分配在栈中的。

- 函数被调用时，栈会分配一部分空间存放该函数中的局部变量（包括参数），这片新分配的存储空间中原来的内容是什么，局部变量的初始内容也就是什么，因此局部变量的初始值是不可预测的。

- 函数调用结束后，局部变量占用的存储空间就被回收，以便分配给下一次函数调用中涉及的局部变量。

- 为什么不将局部变量自动初始化为全 0 呢？因为一个函数的局部变量在内存中的地址，在每次函数被调用时都可能不同，因此自动初始化的工作就不是一次性的，而是每次函数被调用时都耍做，这会带来无谓的时间开销。

- 当然，如果程序员在定义局部变量时将其初始化了，那么这个初始化的工作也是每次函数被调用时都要做的，但这是编程者要求做的，因而不会是无谓的。

- 对象的初始化对象和基本类型的变量一样，定义时也可以进行初始化。一个对象，其行为和内部结构可能比较复杂，如果不通过初始化为其某些成员变量赋予一个合理的值，使用时就会产生错误。例如，有些以指针为成员变量的类可能会要求其对象生成时，指针就已经指向一片动态分配的存储空间。

- 对象的初始化往往不只是对成员变量赋值这么简单，也可能还要进行一些动态内存分配、打开文件等复杂的操作，在这种情况下，就不可能用初始化基本类型变量的方法来对其初始化。

- 虽然可以为类设汁一个初始化函数，对象定义后就立即调用它，但这样做的话，初始化就不具有强制性，难保程序员在定义对象后不会忘记对其进行初始化。面向对象的程序设计语言倾向于对象一定要经过初始化后，使用起来才比较安全。因此，引入了构造函数（constructor）的概念，用于对对象进行自动初始化。

- - **面向对象编程思想**

- C语言也可以用这种思想来写一个类

- - **入口函数**

- argc参数个数，argv参数（argument counter，argument vector）

- - **C语言输入输出**

- printf/scanf是格式化输出/输入

- gets/puts是字符流输入/输出

- - **c++为什么要提出引用：**

- 1）引用作为变量的别名，比使用指针安全且方便

- 我们在用指针的使用经常犯得错是什么：1，操作空指针，2，操作野指针，3，不知不觉改变了指针的值，而后还以为该指针正常。

- 引用区别于指针的特性是：1，不存在空引用（保证不操作空指针），2，必须初始化（保证不是野指针），3，一个引用永远指向他初始化的那个对象（保证指针值不变）。

- 指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元，即指针是一个实体；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。

- ★相同点：

- ●都是地址的概念；

- 指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。

- ★不同点：

- ●指针是一个实体，而引用仅是个别名；

- ●引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；

- ●引用没有const，指针有const，const的指针不可变；（具体指没有int& const a这种形式，而const int& a是有    的， 前者指引用本身即别名不可以改变，这是当然的，所以不需要这种形式，后者指引用所指的值不可以改变）

- ●引用不能为空，指针可以为空；

- ●“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；

- ●指针和引用的自增(++)运算意义不一样；

- 2）引用作为函数参数引用传递和作为函数返回值的时候

- 可以避免直接拷贝对象带来的开销

- - **关于默认初始化元素的初始值**

- 内置类型：如int，函数体外（全局变量）初始为0，函数体内是未定义

- 非内置类型：如string，初始化为空

- - **缓冲区溢出**

- 主要原因是试图通过一个越界的索引去访问容器的内容，容器类型包括string、vector和数组等

- - **C语言中的空字符      '\0'**

- 位模式为全0

- - **RAII**

- Resource Acquisition Is Initialization

- - **除法向上取整**

- (M + N - 1) / N

- - 表达式里同时有无符号类型和有符号类型的时候，有符号类型会转化为无符号类型
  - cat表示CONCATENATE拼接