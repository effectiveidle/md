# 前言

Blockchain是Fintech领域的一项基础性创新，是新一代Distributed Ledger Technology（DLT）系统的核心技术，涉及分布式系统、密码学、博弈论、网络协议等学科知识

# 区块链的诞生

记账问题发展到分布式场景下的天然结果

## 记账的千年演化

阶段一：单式账本，通过单条记录进行账目记录，也称简单记账

阶段二：复式账本，将每笔交易分别在贷方(来源方)和借方(目标方)两个科目进行记录，且借贷双方的总额应该时刻保持相等

阶段三：数字化账本，使用数字媒介记账

阶段四：分布式账本

## 分布式记账发展

方案一：简单分布式记账结构，多方均允许对账本进行任意读写，无法确保账本记录的正确性

方案二：带有数字摘要验证的分布式记账，Digital Digest技术，防止交易被篡改，当存在大量交易历史时计算成本将变得很高

方案三：带有数字摘要验证的可扩展的分布式账本，当交易发生后只需要验证新的交易

## 比特币的出现

首次从实践意义上实现了安全可靠的非中心化数字货币机制：

不需要中心化的支持机构参与，纯靠分布式机制

准确、公正地记录发生过的每一笔交易，并且无法被恶意篡改

匿名化交易，保证隐私

## 区块链的商业价值

技术角度：分布式容错性高、不可篡改性、隐私保护性

业务特性：可信任性、降低成本、增强安全

![计算机生成了可选文字: 区块链](C:\flow\md\img\clip_image001-1611497834176.png)

# 核心技术概览

## 定义与原理

**Wikipedia**上给出的定义中，将区块链类比为一种分布式数据库技术，通过维护数据块的链式结构，可以维持持续增长的、不可篡改的数据记录。

**狭义上**：区块链是一种以区块为基本单位的链式数据结构，区块中利用数字摘要对之前的交易历史进行校验，适合分布式记账场景下防篡改和可扩展性的需求。

**广义上**：区块链还指代基于区块链结构实现的分布式记账技术，包括分布式共识、隐私与安全保护、点对点通信技术、网络协议、智能合约等。

以比特币为例理解区块链工作过程：

1.首先用户通过比特币客户端发起一项交易，消息广播到比特币网络中等待确认，网络中的节点会将收到的交易请求打包在一起，添加前一个区块头部的哈希值等信息，然后试图找到一个nonce串添加到区块，使得区块的哈希值满足一定条件

2.一旦节点找到了满足条件的nonce串，这个区块就成为候选区块，在网络中广播出去

3.其他节点收到候选区块后进行验证，发现合法后添加到自己维护的本地区块链结构上，当大部分节点都接受了该区块后，区块中所包括的交易也就得到确认

## 区块链技术应用的发展

![计算机生成了可选文字: 从计笪特点上，可以看到现有区块链技术的三种典型演化场景 场景 数字货币 分布式应用 带杈限的分 布式账朩 功能 记账 功能 智能 商业 处理 智能台约 不带有競较 图灵完备 多种浯言 图灵完备 一致性 POW POWs POS 阝艮 扌寺 兴 型 联 性 能 较 受 可 包ECFT、BFT在内的多 种机制，可插拔 程浯 简单 特定浯 高级 程浯凸 币网 以太 坊网 超级 账朩](C:\flow\md\img\clip_image002-1611497811802-1611497840301.png)

## 面临的问题和挑战

①隐私保护

②分布式共识：比特币引入的pow的核心思想是基于经济利益的博弈，让恶意破坏的参与者损失经济利益，从而保证大部分人的合作，并通过概率模型保证最后参与方共识到最长链，问题在于效率的低下和能源的浪费

③交易性能：区块链在高频交易的场景不适用，离大规模交易系统每秒稳定数万笔的吞吐性能还有较大差距

④扩展性：当网络中节点数过多时，可能会因为共识延迟而降低整个网络的性能

⑤安全防护

⑥数据库和存储系统：需要设计专门服务区块链的更具针对性的数据库

# 分布式系统核心技术

## 一致性问题

Consistency

- 在分布式系统领域中是指对于多个服务节点，给定一系列操作，在约定协议的保障下，使得它们对处理结果达成“某种程度”的协同

核心思想

- 将可能引发不一致的并行操作进行**串行化**

## 共识算法

一致性指的是多个副本对外呈现的状态，而共识则指在分布式系统中多个节点之间对某个事件达成一致看法的过程，达成某种共识并不意味着就保障了一致性。

State Machine Replication

- 分布式系统中各个节点通常都是相同的确定性状态机模型（又称为状态机复制问题），从相同初始状态开始接收相同顺序的指令，则可以保证相同的结果状态。因此，系统中多个节点最关键地是对多个事件的顺序进行共识，即排序。

Non-Byzantine Fault（Crash Fault）

根据解决的场景是否允许拜占庭错误情况，共识算法分为

- CFT（Paxos、Raft）
- BFT（PBFT、PoW）

## FLP不可能原理

在网络可靠，但**允许节点失效**（即便只有一个）的最小化**异步**模型系统中，不存在一个可以解决一致性问题的确定性共识算法

- 同步，指系统中的各个节点的时钟误差存在上限；并且消息传递必须在一定时间内完成，否则认为失败；同时各个节点完成处理消息的时间是一定的。因此同步系统中可以很容易地判断消息是否丢失。
- 异步，则意味着系统中各个节点可能存在较大的时钟差异；同时消息传输时间是任意长的；各节点对消息进行处理的时间也可能是任意长的。这就造成无法判断某个消息迟迟没有被响应是哪里出了问题（节点故障还是传输故障？）。

## CAP原理

<img src="../img/v2-44e5fb78a506c61d3f03169b8ab43c27_720w.jpg" alt="img" style="zoom: 50%;" />

## ACID原则与多阶段提交

ACID原则描述了分布式数据库需要满足的一致性需求，同时允许付出可用性的代价

- Atomicity：每次事务是原子的，事务包含的所有操作要么全部成功，要么全部不执行。一旦有操作失败，则需要回退状态到执行事务之前；
- Consistency：数据库的状态在事务执行前后的状态是一致的和完整的，无中间状态。即只能处于成功事务提交后的状态；
- Isolation：各种事务可以并发执行，但彼此之间互相不影响。按照标准 SQL 规范，从弱到强可以分为未授权读取、授权读取、可重复读取和串行化四种隔离等级；
- Durability：状态的改变是持久的，不会失效。一旦某个事务提交，则它造成的状态变更就是永久性的。

两阶段提交：

- 预提交：协调者（Coordinator）发起提交某个事务的申请，各参与执行者（Participant）需要尝试进行提交并反馈是否能完成；
- 正式提交：协调者如果得到所有执行者的成功答复，则发出正式提交请求。如果成功完成，则算法执行成功。

三阶段将预提交阶段进一步拆分：

- 尝试预提交：协调者询问执行者是否能进行某个事务的提交。执行者需要返回答复，但无需执行提交。这就避免出现部分执行者被无效阻塞住的情况。
- 预提交：协调者检查收集到的答复，如果全部为真，则发起提交事务请求。各参与执行者（Participant）需要尝试进行提交并反馈是否能完成；
- 正式提交：协调者如果得到所有执行者的成功答复，则发出正式提交请求。如果成功完成，则算法执行成功。

## Paxos算法与Raft算法

[共识算法]: ./ConsensusAlgorithm.md

## 拜占庭问题与PBFT算法

# 密码学与安全技术

主要用于身份认证和隐私保护

## Hash算法与数字摘要

可以将任意长度的二进制明文串映射为较短的（通常是固定长度的）二进制串

常见的Hash算法：Message Digest（MD）和Secure Hash Algorithm（SHA），以及国内SM3

数字摘要是Hash算法的重要用途之一，是对原始数字内容进行Hash运算，获取唯一的摘要值，Hash算法并不是一种加密算法，不能用于对信息的保护

## 加解密算法

加解密系统的典型组件包括算法和密钥(包括加密密钥、解密密钥)，加解密算法自身是固定不变的，一般来说密钥需要在加密前按照特定算法随机生成

![计算机生成了可选文字: 优势 计效率高，加密 对称加 密 非对称 加密 加解密的密钥 相同 加解密的密钥 不相同 代表法 3DESs IDEA AESS 提前共享密钥，易泄臨 计效率低，存在中间人 无提前共享密钥 攻击可能 RSA,EIGamal.椭圆 曲线法](C:\flow\md\img\clip_image003-1611497811802-1611497842796.png)

## 消息认证码

利用对称加密，对消息的摘要进行加密，对消息的完整性进行保护

## 数字签名

数字签名证明消息是某个特定的人发送的，用私钥加密的消息称为签名，用公钥解密签名称为验证签名，一般对消息的哈希值进行签名

举例：Alice 可以先对文件内容进行摘要，然后用自己的私钥对摘要进行加密（签名），之后同时将文件和签名都发给 Bob。Bob 收到文件和签名后，用 Alice 的公钥来解密签名，得到数字摘要，与对文件进行摘要后的结果进行比对。如果一致，说明该文件确实是 Alice 发过来的（因为别人无法拥有 Alice 的私钥），并且文件内容没有被修改过（摘要结果一致）

目前常见的数字签名算法需要选取合适的随机数作为配置参数

## 数字证书

对于非对称加密算法和数字签名来说，很重要的步骤就是**公钥的分发**

证书：认证机构对公钥进行数字签名，能够证明某个公钥是某个实体拥有，从而实现对用户公钥的安全分发

证书格式：证书文件的后缀一般为.ctr或.cer，对应私钥文件后缀为.key

要实现安全地管理、分发证书需要遵循**PKI**（Public Key Infrastructure）体系

用户可以使用开源软件openssl来生成csr文件(证书申请文件)和对应的私钥文件

## Merkle树结构

### 主要特点

最下面的叶节点包含数据或其哈希值，非叶子节点都是它两个孩子节点内容的哈希值，数根的值实际上代表了对底层所有数据的“数字摘要”

### 典型应用场景

证明某个集合中存在或不存在某个元素：提供该元素各级兄弟节点中的Hash值，可以不暴露集合完整内容而证明某元素存在

快速比较大量数据：两个Merkle tree根相同时，意味两组数据必然相同

快速定位修改：某叶节点数据被修改会使其父节点到根节点的数值发生变化

## Bloom Filter结构

布隆过滤器是一种基于 Hash 的高效查找结构，能够快速（常数时间内）回答“某个元素是否在一个集合内”的问题

### 基于Hash的快速查找

内容->索引；但当映射后的值限定在一定范围内时，Hash冲突的概率会变高，存储系统又不能无限扩展

### 更高效的布隆过滤器

它采用了多个Hash函数来提高空间利用率，可以使用较少空间来表示较大集合的存在关系

对同一个给定输入来说，多个Hash函数计算出多个地址，分别在位串的这些地址上标记为1，进行查找时，进行同样的计算过程，如果都为1，则说明大概率存在该输入

### 同态加密

即对密文直接进行处理和对明文进行处理后再对处理结果加密，得到的结果相同，从抽象代数的角度讲保持了同态性

可以保证加密处理者无法访问到数据自身的信息

# 比特币--区块链思想诞生的摇篮

## 项目简介

2008年，中本聪发布比特币白皮书

特点：非中心化、隐私性、通胀预防(发行通过挖矿实现，发行量每四年减半，有总量上限)

非中心化的技术难关：货币发行、货币防伪、货币交易、避免双重支付攻击（Double spending Attattaack）

## 基本原理和设计

记账本记录网络中所有的**交易历史**，而非记录各个账户的余额，该设计可避免某个交易被重复提交，

比特币采用了 UTXO (Unspent Transaction Outputs)模型，相对于账户模型，UTXO 模型可以更容易实现并行处理和隐私保护，并追踪完整交易路径；但由于需要存储和检索所有交易记录，对节点存储压力较大

除了挖矿获得奖励的**coinbase**交易只有输出，正常情况下的交易包括若干输入和输出，总输入不能小于总输出，多余的部分为交易费用

放进网络中的交易**并非实时**得到确认，一般要再生成几个新的区块后才认为该交易被确认

比特币中一笔合法的交易，必须是引用**付款方的****UTXO**作为交易的输入，并生成新的UTXO（将属于收款方）

比特币的**账户地址**为用户公钥经过一系列Hash及编码运算后生成的20字节的字符串

### 交易过程：

![计算机生成了可选文字: 交易是完成比特币功能的核心概念，一条交易可能包括如下信息 ·付款人地址：台法的地址，公钥经过SHA256和RIPEMDI60两次Hash,得到160位Hash 串， ·付款人对交易的签字确认：确保交易内容不被0改； ·付款人资金的来源交易ID:从哪个交易的辑出作为丕次交易的辑入； ·交易的金额：多少钱，跟输入的差额为交易的服务费， ·收款人地址：台法的地址； ·时河戡．交易何时能生效。 网络中节点收到交易信息后，将进行如下检查 ·交易是否已经处理过 ·交易是否台法。包括地址是否台法、发起交易者是否是输入地址的台法有者、是否是UTXO； ·交易的输入之和是否大于输出之和。 检查都涌满，则将交易标记为台法的未确认交易，并在网络内进行广播。](C:\flow\md\img\clip_image004-1611497811802-1611497845303.png)

### 交易脚本：

交易

保障交易完成（主要用于检测交易是否合法）的核心机制，包括负责输入的解锁脚本（scriptSig）和负责输出的锁定脚本（scriptPubkey）

过程中付款方证明自己所引用的UTXO合法通过“签名脚本”来实现，并且指定“输出脚本”来限制将来能使用新UTXO者只能为指定收款方

脚本命名来源（因为输入脚本最简单的形式 就是给出一个signature，同样，输出脚本最简单的形式就是给出一个Pubkey）

输出脚本的类型：

**P2PK**：输出脚本里直接给出收款人的公钥，输入脚本给出签名，直接用公钥检查签名，这个签名是用私钥对输入脚本所在的整个交易的签名

**P2PKH**：输出脚本里给出收款人公钥的哈希，输入脚本给出签名和公钥

scriptPubKey: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG

scriptSig: <sig> <pubKey>

入栈顺序：<sig> <pubKey> OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG

**P2SH****：**输出脚本给出的是收款人提供的redeemScriptHash（赎回脚本的哈希） ，输入脚本给出签名和赎回脚本，验证后执行赎回脚本

一般用于需要多人签名的的场景，本质上是将复杂度从原来实现中的输出脚本转移到输入脚本的赎回脚本里面，赎回脚本里面给出n个公钥和n、m的值（收款人是电商）

### 区块：

示例：

![img](C:\flow\md\img\clip_image005-1611497811802-1611497847043.png)

### 创新设计

#### *如何避免作恶*

基于经济博弈原理，让非合作者遭受风险和损失

#### *负反馈调节*

比特币网络中，矿工越多，系统就越稳定，挖到矿的概率会降低，比特币价值越高

矿工减少，会让系统更容易导致被攻击，挖到矿的概率会提高，比特币价值越低

## 挖矿过程

挖矿指网络中的维护节点，通过协助生成和确认新区块来获取一定量新增比特币的过程

发布：最初每10分钟生成一个区块，奖励50BTC，21万个区块后自动减半（4年）

难度调整：每隔两周（即经过2016个区块）后根据上衣周期的挖矿时间调整挖矿难度，来使生成区块的时间稳定在10min

## 共识机制

## 闪电网络

将大量交易放到比特币区块链之外进行，只把关键环节放到链上进行确认

## 侧链

以比特币作为主链，其他区块作为侧链，二者通过双向挂钩，可实现比特币从主链转移到侧链进行流通

## 热点问题

### 设计权衡

区块容量、出块间隔时间

### 分叉

Sofe Fork：旧节点仍然能够验证接受新节点产生的交易和区块

Hard Fork：旧节点不接受新节点产生的交易和区块

# 以太坊--挣脱加密货币的枷锁

## 以太坊项目简介

最初目标是打造一个运行智能合约的平台（Platform for Smart Contract）

## 核心概念

### Smart Contract

即以计算机程序的方式来缔结和运行各种合约，智能合约作为运行在以太坊虚拟机EVM中的应用，可以接受来自外部的交易请求和事件

### 账户

Contracts Accounts：存储执行的智能合约代码，只能被外部账户来调用激活

Externally Owned Accounts：以太币拥有者账户，对应到某公钥。账户包括 nonce、balance、storageRoot、codeHash 等字段，由个人来控制。

当合约被调用时，存储其中的智能合约会在矿工处的虚拟机中自动执行，并消耗一定的燃料。燃料通过外部账户中的以太币进行购买。

### 交易

指一个账户到另一个账户的消息数据，消息数据可以是以太币或者合约执行参数

### 燃料

控制某次交易执行指令的上限，每执行一条合约指令会消耗固定的燃料

## 主要设计

### 智能合约相关设计

#### *运行环境*

以太坊虚拟机是一个隔离的轻量级虚拟机环境，运行在其中的智能合约代码无法访问本地网络、文件系统或其它进程

#### *开发**语言*

Solidity，智能合约编写完毕后，用编译器编译为以太坊虚拟机专用的二进制格式（EVM bytecode）

#### *交易模型*

![计算机生成了可选文字: 状态查间和变更 存储空间 易用性 全性 可追溯性 UXTO模型 要回溯历史 较难处理 支扌寺历史 账户模型 自接访问 较小 易于理解和程 要处理好重放攻击等情况 不支扌寺追溯历史](C:\flow\md\img\clip_image006-1611497811803-1611497849782.png)

#### *共识*

目前采用了基于成熟的 PoW 共识的变种算法 Ethash 协议作为共识机制，Ethash 在执行时候需要消耗大量内存，反而跟计算效率关系不大。这意味着很难制造出专门针对 Ethash 的芯片，反而是通用机器可能更加有效。

#### *降低**攻击*

仍然是通过经济激励机制防止少数人作恶

#### *提高扩展性*

分片（sharding）是一组维护和执行同一批智能合约的节点组成的子网络，是整个网络的子集

分片后，同一片内的合约处理是同步的，彼此达成共识，不同分片之间则可以是异步的，可以提高网络整体的可扩展性。

## 相关工具 